// SPDX-License-Idenfier: MIT
pragma solidity ^0.8.18;
/**
@dev in implementation of the MIMC function hash, with solidity 
@notice we used in this funciton only 15 round , and the base 5 as the power
@notice the prime using in this function is the prime that the circom language uses so we can later generate 
        a snark proof with the circuit written in the circom language ;
 */
contract hash {
    
    uint constant prime = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    uint8  constant rounds = 15;
    uint[15]  private   c = [
        0,
        21469745217645236226405533686231592324177671190346326883245530828586381403876,
        50297292308054131785073003188640636012765603289604974664717077154647718767691,
        106253950757591248575183329665927832654891498741470681534742234294971120334749,
        16562112986402259118419179721668484133429300227020801196120440207549964854140,
        57306670214488528918457646459609688072645567370160016749464560944657195907328,
        108800175491146374658636808924848899594398629303837051145484851272960953126700,
        52091995457855965380176529746846521763751311625573037022759665111626306997253,
        4647715852037907467884498874870960430435996725635089920518875461648844420543,
        19720773146379732435540009001854231484085729453524050584265326241021328895041,
        2468135790246813579024681357902468135790246813579024681357902468,
        1357924680135792468013579246801357924680135792468013579246801357,
        8642097531864209753186420975318642097531864209753186420975318642,
        3141592653589793238462643383279502884197169399375105820974944592,
        2718281828459045235360287471352662497757247093699959574966967627
    ];
    
    function mimc5(uint x, uint k) public view returns(uint hash){
        uint lastRound = x;
        uint base;
        uint base2;
        uint base4;
        for (uint i; i<rounds ; i++){
            base = addmod(lastRound,k,prime);
            base = addmod(base, c[i], prime);
            // get the power of two : 
            base2 = mulmod(base, base, prime);
            base4 = mulmod(base2, base2, prime);
            // gat the lastround 
            lastRound = mulmod(base4, base, prime);
        }
        return addmod(lastRound,k,prime);
    }


}
